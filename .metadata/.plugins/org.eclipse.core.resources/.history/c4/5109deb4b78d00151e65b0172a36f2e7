package parser;

import java.util.ArrayList;
import java.util.Iterator;

public class AnalyzeTable {
	
	public static String error = "X";
	public static String acc = "acc";
	
	private DFA dfa;
	
	private String[] actionCol;
	private String[] gotoCol;
	public int actionLength;
	public int gotoLength;
	public int stateNum;
	
	private String[][] content;
	
	public AnalyzeTable(){
		createTable();//建表
		this.actionLength = actionCol.length;
		this.gotoLength = gotoCol.length;
		createDFA();//创建DFA
		this.stateNum = dfa.size();
		this.content = new String[actionLength+gotoLength][stateNum];
		createAnalyzeTable();//填充语法分析表的相关内容
	}
	
	/**
	 * 利用这个方法建立一个LR(1)语法分析表
	 */
	private void createTable(){
		//以下是建立一个表的列
		this.actionCol = new String[CFG.VT.size()];
		this.gotoCol = new String[CFG.VN.size()];
		Iterator<String> iter1 = CFG.VT.iterator();
		Iterator<String> iter2 = CFG.VN.iterator();
		int i = 0;
		int j = 0;
		while(iter1.hasNext()){
			String vt = iter1.next();
			if(!vt.equals(CFG.emp)){
				actionCol[i] = vt;
				i++;
			}
		}
		actionCol[i] = "$";
		while(iter2.hasNext()){
			String vn = iter2.next();
			gotoCol[j] = vn;
			j++;
		}
	}
	
	private ArrayList<DFAState> stateList = new ArrayList<DFAState>();//用于下列递归方法的一个公共的容器
	private ArrayList<Integer> gotoStart = new ArrayList<Integer>();
	private ArrayList<Integer> gotoEnd = new ArrayList<Integer>();
	private ArrayList<String> gotoPath = new ArrayList<String>();
	/**
	 * 利用这个递归方法建立一个用于语法分析的DFA
	 * 不再有项集可插入的判定标准为:
	 */
	private void createDFA(){
		DFAState state0 = new DFAState(0);
		stateList.add(state0);
		stateList.get(0).addNewDerivation(new LRDerivation(getDerivation("S'").get(0),"$",0));
		for(LRDerivation lrd:stateList.get(0).set){
			if(lrd.index < lrd.d.list.size()){
				String A = lrd.d.list.get(lrd.index);//获取・后面的文法符号
				if(CFG.VN.contains(A)){
					ArrayList<String> firstA = first(A);//获取first(ba)
					ArrayList<Derivation> dA = getDerivation(A);
					for(int i=0,length1=dA.size();i<length1;i++){
						for(int j=0,length2=firstA.size();j<length2;j++){
							LRDerivation lrd1 = new LRDerivation(dA.get(i),firstA.get(j),0);
							stateList.get(0).addNewDerivation(lrd1);
						}
					}
				}
			}
		}
		//state0建立成功后开始递归建立其他的状态
		ArrayList<String> gotoPath = stateList.get(0).getGotoPath();
		for(String path:gotoPath){
			ArrayList<LRDerivation> list = stateList.get(0).getLRDs(path);
			addState(0,path,list);//开始进行递归，建立用于分析的DFA
		}
		this.dfa = new DFA(stateList);
	}
	
	/**
	 * 通过输入一个从上一个状态传下来的LR产生式的list获取下一个状态，
	 * 如果该状态已经存在，则不作任何操作，跳出递归，如果该状态不存在，则加入该状态，继续进行递归
	 * @param list
	 * @param lastState 上一个状态的编号
	 */
	private void addState(int lastState,String path,ArrayList<LRDerivation> list){
		DFAState temp = new DFAState(stateList.size());
		for(LRDerivation lrd:list){
			String next = lrd.d.list.get(lrd.index+1);
			ArrayList<String> first = first(next);
			for(String s:first){
				LRDerivation newLrd = new LRDerivation(lrd.d,s,lrd.index+1);
				temp.addNewDerivation(newLrd);
			}
		}
		if(!stateList.contains(temp)){
			stateList.add(temp);
			gotoStart.add(lastState);
			gotoEnd.add(temp.id);
			gotoPath.add(path);
			ArrayList<String> newPath = temp.getGotoPath();
			if(newPath.size()!=0){
				for(String p:newPath){
					ArrayList<LRDerivation> newList = temp.getLRDs(p);
					addState(temp.id,p,newList);//进一步递归
				}
			}
		}
	}
	
	/**该方法测试通过
	 * 用于获取与一个文法符号相关的产生式
	 * @param v
	 * @return
	 */
	public ArrayList<Derivation> getDerivation(String v){
		ArrayList<Derivation> result = new ArrayList<Derivation>();
		Iterator<Derivation> iter = CFG.F.iterator();
		while(iter.hasNext()){
			Derivation d = iter.next();
			if(d.left.equals(v)){
				result.add(d);
			}
		}
		return result;
	}
	
	/**测试通过
	 * 用于获取一个文法符号的first
	 * @param v
	 * @return
	 */
	private ArrayList<String> first(String v){
		ArrayList<String> result = new ArrayList<String>();
		Iterator<String> iter = CFG.firstMap.get(v).iterator();
		while(iter.hasNext()){
			result.add(iter.next());
		}
		return result;
	}
	
	/**
	 * 利用这个方法填充语法分析表的相关内容
	 */
	private void createAnalyzeTable(){
		
	}
	
	public String ACTION(int stateIndex,String vt){
		return null;
	}
	
	public String GOTO(int stateIndex,String vn){
		return null;
	}
	
	/**
	 * 打印语法分析表
	 */
	public void print(){
		
	}

}
